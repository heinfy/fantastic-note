### 数字枚举（默认）

```typescript
enum Direction {
  Up,
  Down,
  Left,
  Right
}

let direction: Direction = Direction.Up;
console.log(direction); // 输出: 0

// 通过枚举成员的值来访问枚举常量
let dirName: string = Direction[1];
console.log(dirName); // 输出: "Down"
```

**数字枚举在编译后的 JS 中会生成双向映射**

### 字符串枚举

```typescript
enum Direction {
  Up = 'UP',
  Down = 'DOWN',
  Left = 'LEFT',
  Right = 'RIGHT'
}
```

- 每个成员必须显式赋值为字符串。
- 优点：序列化时保留语义（比如发给后端或存日志），不会变成神秘数字。

### ❌ 枚举的争议与替代方案

虽然枚举很强大，但在现代 TypeScript 开发中，**很多人推荐用 `const` + `as const` 或联合类型代替**，原因包括：

- 枚举在运行时会生成额外的 JS 代码（增加包体积）。
- 字符串字面量类型 + 联合类型更轻量、更灵活。

#### 替代写法（推荐）：

```ts
// 使用 const 断言创建“类似枚举”的对象
const Direction = {
  Up: 'UP',
  Down: 'DOWN',
  Left: 'LEFT',
  Right: 'RIGHT'
} as const;

// 推导出类型
type Direction = typeof Direction[keyof typeof Direction];
// 等价于：type Direction = "UP" | "DOWN" | "LEFT" | "RIGHT"

// 使用
let move: Direction = Direction.Up; // ✅
```

这种方式：
- **零运行时开销**（编译后只是普通对象）
- 类型同样安全
- 更符合函数式/不可变风格

---

### 🧩 枚举 vs 联合类型 vs 对象常量

| 方式 | 运行时存在？ | 可反向查找？ | 类型安全 | 推荐场景 |
|------|-------------|------------|--------|--------|
| `enum` | ✅ 是 | 数字枚举可以 | ✅ | 需要反向映射、或与旧代码兼容 |
| `const enum` | ❌ 否（会被内联） | ❌ | ✅ | 极致性能（但限制多） |
| `as const` + 联合类型 | ✅（对象存在） | ❌ | ✅✅ | **现代 TS 项目首选** |

> 💡 `const enum` 会在编译时被完全内联替换，不生成 JS 代码，但不能在动态场景使用（如 `Object.keys()`）。
