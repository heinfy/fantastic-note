> JSX 是 JavaScript 的语法糖，用于描述 UI。 

React 中 **JSX 转换为真实 DOM 的过程** 并不是一步完成的，而是经过 **编译 → Virtual DOM → Reconciliation → 真实 DOM** 多个阶段。以下是完整流程：

---

### 一、整体流程概览
```
JSX 
  ↓（编译）
React.createElement() 调用 
  ↓（运行时）
Virtual DOM（React Element 树） 
  ↓（Reconciliation 协调）
Fiber 树（工作单元） 
  ↓（Commit 阶段）
真实 DOM 操作
```

---

### 二、详细步骤解析

#### 步骤 1️⃣：**JSX 被编译为 `React.createElement()`**
- JSX 是语法糖，**浏览器无法直接执行**。
- 构建工具（如 Babel、TypeScript）在**编译时**将其转换为函数调用。

```jsx
// 源码（JSX）
const element = <h1 className="title">Hello</h1>;

// 编译后（React 17+ 自动引入 jsx runtime）
const element = jsx('h1', { className: 'title' }, 'Hello');

// 或旧版（需手动 import React）
const element = React.createElement('h1', { className: 'title' }, 'Hello');
```

> ✅ 输出是一个**普通 JavaScript 对象**（称为 **React Element**），**不是真实 DOM**！

```js
// React Element 结构示例
{
  type: 'h1',
  props: {
    className: 'title',
    children: 'Hello'
  }
}
```

---

#### 步骤 2️⃣：**构建 Virtual DOM（初始渲染或更新）**
- 当组件首次渲染或状态更新时，React 会**递归调用组件函数/类**，生成一棵完整的 **React Element 树**（即 Virtual DOM）。
- 这棵树是**轻量级、纯 JS 的对象树**，描述了 UI 应该是什么样子。

---

#### 步骤 3️⃣：**Reconciliation（协调）—— Diff 算法**
- React 将**新的 Virtual DOM 树**与**旧的 Virtual DOM 树**进行对比（Diff）。
- 基于以下策略找出最小变更：
  - 不同类型的元素 → 重建子树
  - 列表使用 `key` 识别稳定项
  - 同层节点逐个对比
- 生成一个**操作列表（patches）**，如：插入、更新、删除。

> 🔧 此过程在 **Fiber 架构**下可中断、可优先级调度（React 16+）。

---

#### 步骤 4️⃣：**Commit 阶段 —— 应用到真实 DOM**
- React **批量执行**上一步生成的 DOM 操作（避免多次重排重绘）。
- 具体操作包括：
  - `document.createElement()` 创建新节点
  - `node.textContent = ...` 更新文本
  - `node.setAttribute()` 设置属性
  - `parent.appendChild()` / `removeChild()` 插入或删除节点

> ⚡ 所有 DOM 操作都在**一次浏览器 tick 内完成**，保证高效。

---

### 三、关键概念澄清

| 概念 | 说明 |
|------|------|
| **JSX** | 开发者写的语法糖，编译后变成函数调用 |
| **React Element** | 纯 JS 对象，描述“想要什么”，**不可变** |
| **Virtual DOM** | 由 React Elements 组成的树，用于 diff |
| **Fiber Node** | React 16+ 内部数据结构，支持增量渲染 |
| **真实 DOM** | 浏览器实际渲染的节点 |

> ❌ **常见误解**：  
> “JSX 直接变成 DOM” —— 实际中间经过 Virtual DOM 和协调过程。

---

### 四、示例：完整流程演示

```jsx
function App() {
  return <div>Hello</div>;
}

// 1. 编译后
const element = jsx('div', {}, 'Hello');

// 2. 渲染时生成 Virtual DOM
const virtualDOM = {
  type: 'div',
  props: { children: 'Hello' }
};

// 3. Reconciliation：对比新旧 Virtual DOM（首次渲染无旧树）

// 4. Commit：执行 DOM 操作
const realDiv = document.createElement('div');
realDiv.textContent = 'Hello';
document.body.appendChild(realDiv);
```

---

### 五、为什么需要 Virtual DOM？

React 和 Vue 使用**虚拟 DOM（Virtual DOM）**，核心目的是在**实现高性能的 UI 更新，并保证开发的简洁高效**。

| 优点 | 虚拟 DOM 的作用 |
|------|----------------|
| **简化开发** | 声明式编程，开发者只关心状态，不关心 DOM 操作 |
| **保证性能** | JS 对象操作比 DOM 操作快得多；<br />通过智能 Diff 和**批处理**，合并多次更新，减少 DOM 操作次数；<br />**组件化**：Virtual DOM 描述 UI，可复用、可组合；<br />**可测试性**：虚拟 DOM 描述 UI，可测试；<br />**可控性**：React 完全掌控更新时机和方式 |
| **跨平台** | 作为平台无关的抽象层，Virtual DOM 可渲染到 Web、Native、Canvas 等（如 React Native）等 |
| **安全可靠** | 框架统一管理 DOM 更新，减少 bug 和安全风险 |


> 💡 注意：Virtual DOM **本身不快**，它的价值在于 **“智能 diff + 批量更新”**。

---

### 总结

| 阶段 | 输入 | 输出 | 工具/机制 |
|------|-----|------|----------|
| **编译** | JSX | `React.createElement` / `jsx()` 调用 | Babel / TS |
| **运行时** | 函数调用 | Virtual DOM（React Element 树） | React Runtime |
| **协调** | 新旧 Virtual DOM | 最小操作集 | Fiber + Diff 算法 |
| **提交** | 操作集 | 真实 DOM 更新 | DOM API 批量执行 |

> ✅ **核心思想**：  
> **“用 JS 描述 UI → 智能计算差异 → 高效更新真实 DOM”**  
> 这就是 React 高性能和声明式编程的基础。
