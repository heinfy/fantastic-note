<details>
<summary>点击查看折叠的代码</summary>

```html
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>浮动导致高度塌陷演示</title>
    <style>
      /* 页面基础样式 */
      body {
        font-family: sans-serif;
        padding: 20px;
        background-color: #f4f4f4;
      }

      /* 
      【问题源头】父容器 
      故意不写 height，依赖子元素撑开高度
    */
      .parent {
        background-color: #ffcccc;
        /* 浅红色背景，方便观察高度 */
        border: 2px solid #ff0000;
        width: 300px;
        /* 注意：这里没有写 height，也没有清除浮动 */
        margin-bottom: 20px;
      }
      /* 浮动的子元素 */
      .box {
        float: left;
        /* 关键：脱离文档流 */
        width: 100px;
        height: 100px;
        background-color: #333;
        color: white;
        text-align: center;
        line-height: 100px;
        margin-right: 10px;
      }

      /* 
      【受害元素】父容器后面的兄弟元素 
      正常情况下应该在红色盒子下面，但因为红色盒子高度塌陷为0，
      它会跑上去占据位置
    */
      .sibling {
        background-color: #4da6ff;
        color: white;
        padding: 10px;
      }

      h3 {
        margin-top: 0;
      }

      p {
        font-size: 14px;
        color: #555;
      }
    </style>
  </head>

  <body>
    <h3>❌ 未清除浮动的效果（高度塌陷）</h3>
    <p>观察：红色父容器的高度变成了0（背景消失），蓝色盒子跑到了黑色方块的下面/后面。</p>

    <!-- 父容器 -->
    <div class="parent">
      <div class="box">浮动1</div>
      <div class="box">浮动2</div>
      <div class="box2">非浮动元素</div>
      <!-- 父容器只能感知 box2 高度 -->
    </div>

    <!-- 兄弟元素（受害者） -->
    <div class="sibling">
      我是下面的兄弟元素。
      <br />
      因为上面的父容器高度塌陷为0，我向上移动了！
      <br />
      我的内容现在被黑色的浮动块遮挡住了。
    </div>
  </body>
</html>
```
</details>

---

展示效果：

![image-20260228上午105940351](assets/image-20260228上午105940351.png)


## 清除浮动

**CSS 清除浮动（Clear Float）** 主要用于解决因元素浮动（`float`）导致的父容器高度塌陷问题。

### 1. 什么是“浮动”带来的问题？
在 CSS 中，当一个元素设置了 `float: left` 或 `float: right` 时，它会脱离正常的文档流（Normal Document Flow）。
*   **现象**：如果父容器内的所有子元素都浮动了，父容器就无法检测到这些子元素的高度，导致父容器的高度变为 **0**（这就是所谓的**高度塌陷**）。
*   **后果**：父容器后面的元素会“挤”上来，占据浮动元素原本的位置，导致页面布局混乱。


### 2. “清除浮动”是什么意思？
**清除浮动**就是通过某种 CSS 技巧，强制让父容器“感知”到内部浮动子元素的高度，从而自动撑开父容器的高度，恢复正常的文档流布局。

---

### 3. 常见的清除浮动方法

#### 方法一：使用 `clear` 属性
在浮动元素的后面添加一个空的块级元素，并设置 `clear: both`。
```css
.clearfix {
  clear: both;
}
````

```html
<div class="parent">
  <div
    class="child"
    style="float: left;"
  >
    内容
  </div>
  <!-- 添加一个空标签来清除浮动 -->
  <div class="clearfix"></div>
</div>
```

- **缺点**：需要在 HTML 中增加无意义的标签，不符合结构与样式分离的原则，现在较少使用。

#### 方法二：使用 `overflow` 属性

给父容器设置 `overflow` 属性（通常为 `hidden` 或 `auto`）。

```css
.parent {
  overflow: hidden; /* 或 overflow: auto */
}
```

- **原理**：这会触发浏览器的 **BFC (Block Formatting Context，块级格式化上下文)**。在 BFC 中，父容器会包含其内部浮动的子元素。
- **缺点**：如果子元素有超出父容器的部分（如下拉菜单、阴影等），会被直接裁剪掉，可能产生副作用。

#### 方法三：使用伪元素 `::after`

这是目前最主流、兼容性最好且无需修改 HTML 结构的方法。通常将其封装为一个类（如 `.clearfix`）。

```css
.clearfix::after {
  content: ''; /* 必须生成内容 */
  display: block; /* 转换为块级元素 */
  clear: both; /* 清除左右浮动 */
  visibility: hidden; /* 隐藏元素（可选，防止占位影响） */
  height: 0; /* 高度设为0 */
}

/* 兼容旧版 IE (IE6/7) */
.clearfix {
  *zoom: 1;
}
```

**使用方式：**

```html
<div class="parent clearfix">
  <div
    class="child"
    style="float: left;"
  >
    左侧浮动
  </div>
  <div
    class="child"
    style="float: right;"
  >
    右侧浮动
  </div>
  <!-- 不需要在 HTML 里加任何额外标签 -->
</div>
```

- **优点**：不污染 HTML 结构，兼容性好，不会产生副作用。

#### 方法四：使用 Flexbox 或 Grid

如果你不需要支持非常古老的浏览器（如 IE），可以直接使用现代布局模型，它们天然就不存在浮动塌陷问题。

```css
.parent {
  display: flex; /* 或 display: grid */
}
```

- **注意**：这实际上是**替代**了浮动布局，而不是“清除”浮动。在现代开发中，能不用 `float` 做布局就尽量不用。

## 为什么文字没有被浮动元素遮挡住

**“浮动元素虽然脱离了文档流（导致父容器高度塌陷），但它并没有完全脱离‘文字流’。”**

简单来说：**块级盒子（如 div）会被浮动元素覆盖或挤开，但行内内容（如文字、图片）会主动“环绕”在浮动元素周围。**

### 核心原因：浮动的定义

CSS 规范规定，`float` 的设计初衷就是为了实现**“文字环绕图片”**的效果（就像报纸排版一样）。

因此，浏览器渲染引擎遵循以下两条铁律：

1.  **对于块级盒子（Block Boxes）**：浮动元素会脱离文档流。后面的块级元素（如你的 `.sibling` div）会忽略浮动元素的存在，尝试占据它原本的位置（这就是为什么蓝色背景跑上去了，看起来像被“遮挡”或“重叠”了）。
2.  **对于行内内容（Inline Content）**：浮动元素**不会**遮挡行内内容。浏览器会自动计算空间，将文字“挤”到浮动元素的旁边或下方，确保文字可见。

让我们拆解一下 `.sibling` 这个蓝色盒子的渲染过程：

- **蓝色背景（块级部分）**：
  - 因为它是一个块级容器，它认为上面的红色父容器高度为 0。
  - 所以，蓝色盒子的**背景区域**直接向上延伸，覆盖到了黑色浮动块的下方/后方。
  - **现象**：你看不到红色背景，且蓝色背景似乎和黑色方块重叠了。

- **蓝色盒子里的文字（行内部分）**：
  - 当浏览器准备绘制文字时，它检测到了前方有 `float: left` 的黑色方块。
  - 为了防止文字被遮住，浏览器**强制**将文字向右移动（或者向下换行），直到找到足够的空白区域。
  - **现象**：文字乖乖地排在了黑色方块的右边或下边，完全没有被挡住。

### 总结

- **高度塌陷**：是因为父容器忽略了**块级**的浮动子元素。
- **文字不遮挡**：是因为 CSS 规范强制要求**行内内容**必须避开浮动元素，进行自动重排（Reflow）。

## 为什么背景重叠但文字环绕

要从**浏览器底层渲染原理**解释“为什么背景重叠但文字环绕”，我们需要深入浏览器的**渲染流水线（Rendering Pipeline）**，特别是**布局（Layout）**和**绘制（Paint）**这两个阶段，以及**盒模型（Box Model）**与**行框（Line Box）**的区别。

现代浏览器（如 Chrome 的 Blink 引擎）渲染页面主要经历以下步骤：

1.  **DOM/CSSOM 构建** -> 2. **渲染树（Render Tree）构建** -> 3. **布局（Layout/Reflow）** -> 4. **绘制（Paint）** -> 5. **合成（Composite）**

“浮动”现象的核心冲突发生在 **第3步（布局）** 和 **第4步（绘制）** 对不同类型内容的处理逻辑差异上。

---

### 1. 核心概念：两种不同的“流”

在浏览器内核中，元素被分为两类处理逻辑：

- **块级格式化上下文 (Block Formatting Context, BFC) 中的块级盒子**：负责占据矩形空间。
- **行内格式化上下文 (Inline Formatting Context, IFC) 中的行内内容**：负责文字换行、排列。

**浮动（Float）的本质定义是：**

> “一个浮动元素会脱离正常的**块级流（Block Flow）**，但它仍然参与**行内流（Inline Flow）**。”

这就是所有现象的根源。

---

### 2. 第一阶段：布局（Layout / Reflow）—— 计算位置

在这个阶段，浏览器计算每个元素在屏幕上的几何位置（x, y, width, height）。

#### A. 对“块级盒子”（`.sibling` 的蓝色背景）的处理

- **规则**：在普通文档流中，块级盒子的垂直位置由前一个块级盒子的下边缘决定。
- **浮动的特殊性**：当浏览器计算 `.sibling` 的位置时，它会检查前面的元素。如果发现前面的元素是 `float`，**块级布局算法会忽略它**。
  - 浏览器认为：“前面的红色父容器高度为0（因为子元素浮动了，没撑开高度），所以 `.sibling` 的顶部应该紧贴着红色父容器的底部（也就是黑色方块的顶部）。”
  - **结果**：`.sibling` 的**边界框（Bounding Box）**被计算在了黑色浮动块的**上方/重叠区域**。
  - **底层数据结构**：在渲染树中，`.sibling` 的 `y` 坐标很小，它的矩形区域与浮动块的矩形区域在空间上是**重叠**的。

#### B. 对“行内内容”（文字）的处理

- **规则**：文字不是作为一个大矩形存在的，而是被切割成一个个**行框（Line Boxes）**。
- **浮动的特殊性**：当浏览器构建 **行框（Line Box）** 时，它会查询当前行所在的水平空间是否有“障碍物”。
  - 浏览器检测到左侧有一个浮动块（黑色方块）。
  - **行框构建算法**：`Line Box Width = Container Width - Float Width`。
  - 浏览器会**收缩**行框的有效宽度，或者将行框向下移动，直到找到没有浮动块遮挡的完整一行。
  - **结果**：虽然 `.sibling` 的大盒子（背景）位置在上方，但里面的**行框**被强制向右挤压或向下推移，避开了浮动块的矩形区域。

**总结布局阶段：**

- **块级盒子（背景）**：忽略了浮动，位置计算发生了**重叠**。
- **行内盒子（文字）**：感知到了浮动，位置计算发生了**避让**。

---

### 3. 第二阶段：绘制（Paint）—— 分层涂抹

布局完成后，浏览器进入绘制阶段，将像素画到屏幕上。这里涉及**层叠上下文（Stacking Context）**和**绘制顺序**。

#### A. 背景绘制的顺序

浏览器的绘制顺序通常如下（从后往前）：

1.  背景和边框（属于块级盒子本身）。
2.  子元素的内容。
3.  浮动元素（Floats）。
4.  行内内容（Inlines）。
5.  ...其他...

**关键点来了：**

1.  浏览器先绘制 `.sibling` 的**蓝色背景**。由于布局阶段计算出它的区域与黑色方块重叠，所以蓝色背景被画在了黑色方块的**下面**（或者如果浮动元素层级更高，则被盖住，但在标准流中，浮动元素通常绘制在普通流块级背景之上，或者取决于具体的层叠上下文，但通常**背景是被视为底层**）。
    - _修正_：实际上，根据 CSS 2.1 规范，浮动元素是在**普通流块级元素的背景之后**，但在**普通流块级元素的内容之前**绘制的。
    - **顺序**：
      1. 画 `.sibling` 的蓝色背景（覆盖在浮动块区域）。
      2. 画黑色浮动块（盖在蓝色背景上面）。
      3. 画 `.sibling` 的文字（盖在黑色浮动块上面？**不！** 见下一步）。

#### B. 文字绘制的“避让”真相

其实，文字并没有被“画在浮动块上面然后没被挡住”，而是**根本就没在那个坐标上画**。

- 在**布局阶段**，文字的行框（Line Box）坐标已经被修改了。
- 假设黑色方块占据 `x: 0-100`。
- 正常文字应该在 `x: 0-300`。
- 但因为浮动，布局引擎计算出的文字行框起始坐标变成了 `x: 110-300`（或者换行到 `y: 110`）。
- **绘制阶段**：GPU 只是忠实地把文字像素画在 `x: 110` 开始的地方。
- **视觉效果**：文字看起来像是“绕”过了黑色方块。

**如果文字真的在黑色方块下面（坐标重叠）会发生什么？** 如果强制让文字坐标重叠（例如使用 `position: absolute`），那么在绘制阶段，根据 `z-index` 或默认层叠顺序，文字要么被黑色方块挡住，要么挡在黑色方块上面（取决于谁层级高）。但**浮动机制在布局阶段就物理隔离了文字的坐标**。

---

### 4. 底层数据结构图解

想象浏览器的内存中存在这样的结构：

```json
{
  "element": ".sibling",
  "layout_box": {
    "x": 0,
    "y": 100, // 这里的 Y 坐标很高，与浮动块重叠！
    "width": 300,
    "height": 200,
    "background_paint_area": [0, 100, 300, 200] // 背景会画在这个重叠区域
  },
  "inline_children": [
    {
      "type": "text_line_1",
      "layout_box": {
        "x": 110, // 注意！X 坐标被推到了浮动块右边
        "y": 105,
        "width": 190, // 宽度变窄了
        "content": "我是文字..."
      }
    }
  ]
}
```

- **背景**使用的是 `element.layout_box`，它与浮动块重叠。
- **文字**使用的是 `inline_children.layout_box`，它被**重新计算**过，避开了浮动块。

### 5. 总结：为什么会有这种“分裂”行为？

这是 CSS 规范为了兼容**“图文混排”**历史需求而设计的特殊渲染路径：

1.  **块级流（Block Flow）**：为了保持文档结构的连贯性，允许块级盒子“穿透”浮动（导致高度塌陷和背景重叠），这样后续的块级元素才能紧接着排列，而不是被浮动元素无限挤到页面底部。
2.  **行内流（Inline Flow）**：为了保证可读性，强制行框在布局计算时避开浮动区域。

**一句话概括底层原理：** 在**布局（Reflow）**阶段，浏览器对**块级盒子**忽略了浮动占位（导致坐标重叠），但对**行框（Line Box）**执行了**排除浮动区域**的几何计算（导致坐标避让）。因此在**绘制（Paint）**阶段，背景画在了重叠区，而文字画在了避让区。
